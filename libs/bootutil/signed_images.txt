Image signing

This signs the image by computing hash over the image, and then
signing that hash. Signature is computed by newt tool when it's
creating the image. This signature is placed in the image trailer.

The public key of this keypair must be included in the bootloader,
as it verifies it before allowing the image to run.

This facility allows you to use multiple signing keys. This would
be useful when you want to prevent production units from booting
development images, but want development units to be able to boot
both production images and development images.

First you need a keypair to use for signing. You can create
one with openssl command line tool.

openssl genrsa -out image_sign.pem 2048

This created a file which contains both the private and public key,
and will be used when signing images.

Then you need to extract the public key from this to include it
in the bootloader. Bootloader need to keep key parsing minimal,
so it expects simple key format.

openssl rsa -in image_sign.pem -pubout -out image_sign_pub.der -outform DER -RSAPublicKey_out

Now the public key is in file called image_sign_pub.der.

xxd -i image_sign_pub.der image_sign_pub.c

Then you need to create a package containing this key, or keys.
In the pkg.yml for this package, you advertise feature IMAGE_KEYS.
Once this is done, bootloader will expect keys to be filled in
'bootutil_keys', and the number of keys to be in 'bootutil_key_cnt'.

Here is sample pkg.yml:
pkg.name: libs/mykeys
pkg.deps:
    - libs/bootutil
pkg.features.bootloader:
    - IMAGE_KEYS

And sample source file which includes the keys:
#include <bootutil/sign_key.h>

#include "image_sign_pub.c"

const struct bootutil_key bootutil_keys[] = {
    [0] = {
        .key = image_sign_pub_der2,
        .len = &image_sign_pub_der2_len,
    }
};

const int bootutil_key_cnt = sizeof(bootutil_keys) / sizeof(bootutil_keys[0]);
